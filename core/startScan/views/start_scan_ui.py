import json
import os
from datetime import datetime

import markdown
from django.contrib import messages
from django.db.models import Count
from django.http import HttpResponse, HttpResponseRedirect, JsonResponse
from django.shortcuts import get_object_or_404, render
from django.template.loader import get_template
from django.urls import reverse
from django.utils import timezone
from django_celery_beat.models import (ClockedSchedule, IntervalSchedule,
                                       PeriodicTask)
from weasyprint import HTML

from core.celery import app
from core.common_func import *
from core.scanEngine.models import EngineType, VulnerabilityReportSetting
from core.startScan.models import *
from core.targetApp.models import Domain, project
from core.tasks import create_scan_activity, initiate_scan


def create_scan_object(host_id, engine_type):
    """
    create task with pending status so that celery task will execute when
    threads are free
    """
    # get current time
    current_scan_time = timezone.now()
    # fetch engine and domain object
    engine_object = EngineType.objects.get(pk=engine_type)
    domain = Domain.objects.get(pk=host_id)
    task = ScanHistory()
    task.scan_status = -1
    task.domain = domain
    task.scan_type = engine_object
    task.start_scan_date = current_scan_time
    task.save()
    # save last scan date for domain model
    domain.start_scan_date = current_scan_time
    domain.save()
    return task.id


def start_scan_ui(request, domain_id):
    domain = get_object_or_404(Domain, id=domain_id)
    if request.method == "POST":
        # get imported subdomains
        imported_subdomains = [
            subdomain.rstrip()
            for subdomain in request.POST["importSubdomainTextArea"].split("\n")
        ]
        imported_subdomains = [
            subdomain for subdomain in imported_subdomains if subdomain
        ]

        out_of_scope_subdomains = [
            subdomain.rstrip()
            for subdomain in request.POST["outOfScopeSubdomainTextarea"].split("\n")
        ]
        out_of_scope_subdomains = [
            subdomain for subdomain in out_of_scope_subdomains if subdomain
        ]
        # get engine type
        engine_type = request.POST["scan_mode"]
        scan_history_id = create_scan_object(domain_id, engine_type)
        # start the celery task
        celery_task = initiate_scan.apply_async(
            args=(
                domain_id,
                scan_history_id,
                0,
                engine_type,
                imported_subdomains,
                out_of_scope_subdomains,
            )
        )
        ScanHistory.objects.filter(id=scan_history_id).update(celery_id=celery_task.id)
        messages.add_message(request, messages.INFO, "Scan Started for " + domain.name)
        return HttpResponseRedirect(reverse("scan_history"))
    engine = EngineType.objects.order_by("id")
    custom_engine_count = EngineType.objects.filter(default_engine=False).count()
    context = {
        "scan_history_active": "active",
        "domain": domain,
        "engines": engine,
        "custom_engine_count": custom_engine_count,
    }
    return render(request, "startScan/start_scan_ui.html", context)
